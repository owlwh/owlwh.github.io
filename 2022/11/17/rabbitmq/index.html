<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>rabbitmq | WUHENG</title><meta name="description" content="RabbitMQ 实战指南RabbitMQ安装及简单使用Windows 安装安装Erlang下载下载Erlang 安装包：http://www.cnerlang.com/resource/182.html  或者通过网盘下载：https://pan.baidu.com/s/1eTkk5BO 密码：wo1b 安装下载完后，一直next，安装完后 配置环境变量ERLANG_HOME&#x3D; ‘你的"><meta name="author" content="WHXY"><meta name="copyright" content="WHXY"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/xiaoyuan.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="rabbitmq"><meta name="twitter:description" content="RabbitMQ 实战指南RabbitMQ安装及简单使用Windows 安装安装Erlang下载下载Erlang 安装包：http://www.cnerlang.com/resource/182.html  或者通过网盘下载：https://pan.baidu.com/s/1eTkk5BO 密码：wo1b 安装下载完后，一直next，安装完后 配置环境变量ERLANG_HOME&#x3D; ‘你的"><meta name="twitter:image" content="http://example.com/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="rabbitmq"><meta property="og:url" content="http://example.com/2022/11/17/rabbitmq/"><meta property="og:site_name" content="WUHENG"><meta property="og:description" content="RabbitMQ 实战指南RabbitMQ安装及简单使用Windows 安装安装Erlang下载下载Erlang 安装包：http://www.cnerlang.com/resource/182.html  或者通过网盘下载：https://pan.baidu.com/s/1eTkk5BO 密码：wo1b 安装下载完后，一直next，安装完后 配置环境变量ERLANG_HOME&#x3D; ‘你的"><meta property="og:image" content="http://example.com/img/post.jpg"><meta property="article:published_time" content="2022-11-17T02:04:00.000Z"><meta property="article:modified_time" content="2022-11-17T02:04:49.521Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://example.com/2022/11/17/rabbitmq/"><link rel="next" title="Spring" href="http://example.com/2022/11/16/test2/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/myavatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ-%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97"><span class="toc-number">1.</span> <span class="toc-text">RabbitMQ 实战指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">RabbitMQ安装及简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.1.</span> <span class="toc-text">Windows 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Erlang"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">安装Erlang</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">下载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text">配置环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F"><span class="toc-number">1.1.1.1.4.</span> <span class="toc-text">验证安装成功</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85RabbitMQ"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">安装RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD-1"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">下载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-1"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-1"><span class="toc-number">1.1.1.2.3.</span> <span class="toc-text">配置环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7management"><span class="toc-number">1.1.1.2.4.</span> <span class="toc-text">激活管理工具management</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.1.2.5.</span> <span class="toc-text">启动停止服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.2.</span> <span class="toc-text">Linux 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Erlang-%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">Erlang 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Erlang"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">安装 Erlang</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-x2F-etc-x2F-profile-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">修改 &#x2F;etc&#x2F;profile 配置文件，添加环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-Erlang-%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">验证 Erlang 是否安装成功</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">RabbitMQ 的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E5%AE%89%E8%A3%85%E5%8C%85"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">解压安装包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-x2F-etc-x2F-profile-%E6%96%87%E4%BB%B6-%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">修改 &#x2F;etc&#x2F;profile 文件 ,添加环境变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">RabbitMQ 的运行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">相关概念介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.2.1.</span> <span class="toc-text">生产者和消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Producer"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Producer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consumer"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Consumer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Broker"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">Broker</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.2.2.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%99%A8%EF%BC%8C%E8%B7%AF%E7%94%B1%E9%94%AE%EF%BC%8C%E7%BB%91%E5%AE%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">交换器，路由键，绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">交换器类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fanout"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">fanout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#direct"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">direct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#topic"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">topic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMQP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.5.</span> <span class="toc-text">AMQP协议介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AF%BC%E5%90%91"><span class="toc-number">1.3.</span> <span class="toc-text">客户端开发导向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5RabbitMQ"><span class="toc-number">1.3.1.</span> <span class="toc-text">连接RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%A4%E6%8D%A2%E5%99%A8%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用交换器和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exchangeDeclare-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">exchangeDeclare 方法详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queueDeclare-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">queueDeclare 方法详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queueBind-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">queueBind 方法详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exchangeBind-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">exchangeBind 方法详解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.3.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.4.</span> <span class="toc-text">消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">推模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">拉模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%A1%AE%E8%AE%A4%E4%B8%8E%E6%8B%92%E7%BB%9D"><span class="toc-number">1.3.5.</span> <span class="toc-text">消费端确认与拒绝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbtiMQ-%E8%BF%9B%E9%98%B6"><span class="toc-number">1.4.</span> <span class="toc-text">RabbtiMQ 进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mandatory-%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">mandatory 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E5%99%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">备份交换器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%88TTL%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">设置过期时间（TTL）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E7%9A%84TTL"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">设置消息的TTL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%98%9F%E5%88%97%E7%9A%84TTL"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">设置队列的TTL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.4.4.</span> <span class="toc-text">死信队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">1.4.5.</span> <span class="toc-text">延迟队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">1.4.6.</span> <span class="toc-text">优先级队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.7.</span> <span class="toc-text">RPC实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.4.8.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%99%A8%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">交换器持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">队列持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">消息持久化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-number">1.4.9.</span> <span class="toc-text">生产者确认</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">事物机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%8F%91%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.9.2.</span> <span class="toc-text">发送发确认机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%B9%E9%87%8F-confirm-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.9.2.1.</span> <span class="toc-text">批量 confirm 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-confirm-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.9.2.2.</span> <span class="toc-text">异步 confirm 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%82%B9%E8%A6%81%E7%82%B9%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.10.</span> <span class="toc-text">消费点要点介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">消息分发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">消息顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">RabbitMQ 管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A7%9F%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90"><span class="toc-number">1.5.1.</span> <span class="toc-text">多租户与权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">用户管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E7%AB%AF%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">web端管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.4.</span> <span class="toc-text">应用与集群管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">应用管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">集群管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E8%BF%90%E7%BB%B4"><span class="toc-number">1.6.</span> <span class="toc-text">RabbitMQ运维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-number">1.6.1.</span> <span class="toc-text">集群搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%9C%BA%E5%A4%9A%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">多机多节点配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">集群节点类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%94%E9%99%A4%E5%8D%95%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">剔除单个节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8D%87%E7%BA%A7"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">集群节点升级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%A4%9A%E8%8A%82%E7%82%B9"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">单机多节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%8A%82%E7%82%B9%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">1.6.2.</span> <span class="toc-text">单节点故障恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%A1%AC%E4%BB%B6%E6%95%85%E9%9A%9C"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">机器硬件故障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E6%8E%89%E7%94%B5"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">机器掉电</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">网络异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">服务进程异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%BF%81%E7%A7%BB"><span class="toc-number">1.6.3.</span> <span class="toc-text">集群迁移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E9%AB%98%E9%98%B6"><span class="toc-number">1.7.</span> <span class="toc-text">RabbitMQ  高阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">存储机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">队列结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">1.7.2.</span> <span class="toc-text">惰性队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8F%8A%E7%A3%81%E7%9B%98%E8%AD%A6%E5%91%8A"><span class="toc-number">1.7.3.</span> <span class="toc-text">内存及磁盘警告</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AD%A6%E5%91%8A"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">内存警告</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AD%A6%E5%91%8A"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">磁盘警告</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E5%88%B6"><span class="toc-number">1.7.4.</span> <span class="toc-text">流控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">流控制原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E9%98%9F%E5%88%97%E7%9A%84%E7%93%B6%E9%A2%88"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">打破队列的瓶颈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97"><span class="toc-number">1.7.5.</span> <span class="toc-text">镜像队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.8.</span> <span class="toc-text">网络分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">网络分区的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">1.8.2.</span> <span class="toc-text">网络分区的判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.8.3.</span> <span class="toc-text">网络分区模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E5%BD%B1%E5%93%8D"><span class="toc-number">1.8.4.</span> <span class="toc-text">网络分区影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.8.5.</span> <span class="toc-text">手动处理网络分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.8.6.</span> <span class="toc-text">自动处理网络分区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%89%A9%E5%B1%95"><span class="toc-number">1.9.</span> <span class="toc-text">RabbitMQ扩展</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">WUHENG</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">rabbitmq</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-11-17 10:04:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2022-11-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-11-17 10:04:49"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2022-11-17</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="RabbitMQ-实战指南"><a href="#RabbitMQ-实战指南" class="headerlink" title="RabbitMQ 实战指南"></a>RabbitMQ 实战指南</h1><h2 id="RabbitMQ安装及简单使用"><a href="#RabbitMQ安装及简单使用" class="headerlink" title="RabbitMQ安装及简单使用"></a>RabbitMQ安装及简单使用</h2><h3 id="Windows-安装"><a href="#Windows-安装" class="headerlink" title="Windows 安装"></a>Windows 安装</h3><h4 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>下载Erlang 安装包：<a target="_blank" rel="noopener" href="http://www.cnerlang.com/resource/182.html">http://www.cnerlang.com/resource/182.html</a> </p>
<p>或者通过网盘下载：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1eTkk5BO">https://pan.baidu.com/s/1eTkk5BO</a> 密码：wo1b</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>下载完后，一直next，安装完后</p>
<h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p>ERLANG_HOME&#x3D; ‘你的erlang安装目录’</p>
<p>PATH 加入%ERLANG_HOME%\bin;</p>
<h5 id="验证安装成功"><a href="#验证安装成功" class="headerlink" title="验证安装成功"></a>验证安装成功</h5><p>打开命令窗口输入命令：erl</p>
<p>得到结果：Eshell V9.2  (abort with ^G)   标识安装成功</p>
<h4 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h4><h5 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h5><p>下载Rabbimq 安装包：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/install-windows.html">https://www.rabbitmq.com/install-windows.html</a></p>
<p>选择与erlang版本对应的RabbitMQ安装包下载，版本对照地址：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/which-erlang.html&gt;">https://www.rabbitmq.com/which-erlang.html&gt;</a></p>
<h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>下载完后，一直next，安装完后</p>
<h5 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p>RABBITMQ_HOME&#x3D; ‘你的rabbitmq安装目录’</p>
<p>PATH 加入%RABBITMQ_HOME%\sbin;</p>
<h5 id="激活管理工具management"><a href="#激活管理工具management" class="headerlink" title="激活管理工具management"></a>激活管理工具management</h5><p>sbin目录下打开命令窗口，输入命令：rabbitmq-plugins.bat enable rabbitmq_management</p>
<h5 id="启动停止服务"><a href="#启动停止服务" class="headerlink" title="启动停止服务"></a>启动停止服务</h5><p>启动：net start RabbitMQ</p>
<p>停止：net stop RabbitMQ</p>
<h3 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h3><h4 id="Erlang-安装"><a href="#Erlang-安装" class="headerlink" title="Erlang 安装"></a>Erlang 安装</h4><p>#####解 压安装包，并配置安装目录</p>
<p>这里我们预备安装到 &#x2F;opt&#x2F;erlang 目录下:<br>[root@hidden -)# tar zxvf otp_src_19 . 3.tar . gz<br>[root@hidden -)# cd otp src 19 . 3<br>[root@hidden otp src_19.3)# .&#x2F;configure –prefix&#x3D;&#x2F;opt&#x2F;er1ang<br>如果出现类似关键报错信息 : No curses library functions found。那么此时需要安装<br>ncurses ，安装步骤(遇到提示输入 y 后直接回车即可)如下:<br>[root@hidden otp_src_19.3)# yum install ncurses-devel</p>
<h5 id="安装-Erlang"><a href="#安装-Erlang" class="headerlink" title="安装 Erlang"></a>安装 Erlang</h5><p>[root@hidden otp_src_19 . 3)# make<br>[root@hidden otp_src_19 . 3)# make install<br>如果在安装的过程中出现类似 “No ***** found” 的提示，可根据提示信息安装相应的包，<br>从新安装，直到提示安装完毕为止。</p>
<h5 id="修改-x2F-etc-x2F-profile-配置文件，添加环境变量"><a href="#修改-x2F-etc-x2F-profile-配置文件，添加环境变量" class="headerlink" title="修改 &#x2F;etc&#x2F;profile 配置文件，添加环境变量"></a>修改 &#x2F;etc&#x2F;profile 配置文件，添加环境变量</h5><p>ERLANG HOME&#x3D;&#x2F;opt&#x2F;erlang<br>export PATH&#x3D;$PATH:$ERLANG HOME&#x2F;bin<br>export ERLANG_HOME<br>最后执行如下命令让配置文件生效 :<br>[root@hidden otp_src_19 .3) # source &#x2F;etc&#x2F;profile</p>
<h5 id="验证-Erlang-是否安装成功"><a href="#验证-Erlang-是否安装成功" class="headerlink" title="验证 Erlang 是否安装成功"></a>验证 Erlang 是否安装成功</h5><p>[root@hidden -)# erl<br>Erlang&#x2F;OTP 19 [erts-8.1) [source) [64-bit) [smp:4 : 4) [async-threads : 10) [hipe)<br>[kernel-poll:false)<br>Eshell V8 . 1 (abort with ^G )</p>
<h4 id="RabbitMQ-的安装"><a href="#RabbitMQ-的安装" class="headerlink" title="RabbitMQ 的安装"></a>RabbitMQ 的安装</h4><h5 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h5><p>官网下载地址 :<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/download.html#server-installation-guides">https://www.rabbitmq.com/download.html#server-installation-guides</a><br>将 RabbitMQ 安装到与 Erlang 同一个目录 (&#x2F; opt) 下面 :<br>[root@hidden -]# tar zvxf rabbitmq-server- generic-unix-3.6.10 . tar . gz -c lopt<br>[root@hidden - ]# cd lopt<br>[root@hidden -]# mv rabbitmq_server-3 . 6.10 rabbitmq</p>
<h5 id="修改-x2F-etc-x2F-profile-文件-添加环境变量"><a href="#修改-x2F-etc-x2F-profile-文件-添加环境变量" class="headerlink" title="修改 &#x2F;etc&#x2F;profile 文件 ,添加环境变量"></a>修改 &#x2F;etc&#x2F;profile 文件 ,添加环境变量</h5><p>export PATH&#x3D;$PATH : &#x2F;opt&#x2F;rabbitmq&#x2F;sbin<br>export RABBITMQ HOME&#x3D;&#x2F;opt&#x2F;rabbitmq<br>之后执行 source&#x2F;etc&#x2F;profile 命令让配置文件生效。</p>
<h4 id="RabbitMQ-的运行"><a href="#RabbitMQ-的运行" class="headerlink" title="RabbitMQ 的运行"></a>RabbitMQ 的运行</h4><p>在修改了 &#x2F;etc&#x2F;profile 配置文件之后，可以任意打开一个 Shell 窗口，输入如下命令以运行 RabbitMQ 服务 :</p>
<p>rabbitmq-server -detached</p>
<p>在 rabbitmq-s erver 命令后面添加一个 “-detached” 参数是为了能够让 RabbitMQ服务以守护进程的方式在后台运行，这样就不会因为当前 Shell 窗口的关闭而影响服务。</p>
<p>运行 rabbitmqctl status 命令查看 RabbitMQ 是否正常启动，示例如下:<br>[root@hidden -]# rabbitmqctl statu </p>
<p>Status of node rabbit@hidden  &#x2F;&#x2F;省略</p>
<h2 id="相关概念介绍"><a href="#相关概念介绍" class="headerlink" title="相关概念介绍"></a>相关概念介绍</h2><p>RabbitMQ 整体模型</p>
<p> class="lazyload" data-src="https://raw.githubusercontent.com/ExplorerMan9527/image/master/RabbitMQ%E6%95%B4%E4%BD%93%E6%A8%A1%E5%9E%8B.png" <img src="/"></p>
<h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><p>生产者，就是投递消息的 一方。 </p>
<p>消息一般可以包含 2 个部分:消息体和标签<br>C Label) 。消息体也可以称之为 payload ，在实际应用中，消 息体 一般是一个带有业务逻辑结构<br>的数据，比如一个 JSON 字符串 </p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>消费者 ， 就是接收消息的 一方。 </p>
<p>当消费者消费一条消息时 ， 只是消费<br>消息的消息体 C payload ) 。 在消息路由的过程中 ， 消息的标签会丢弃 ， 存入到队列中的消息只<br>有消息体，消费者也只会消费到消息体 ， 也就不知道消息的生产者是谁，当然消费者也不需要<br>知道 。 </p>
<h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>消息中间件的服务节点 。 </p>
<p>RabbitMQ消息流转流程</p>
<p> class="lazyload" data-src="https://raw.githubusercontent.com/ExplorerMan9527/image/master/RabbitMQ%E6%B6%88%E6%81%AF%E6%B5%81%E8%BD%AC%E6%B5%81%E7%A8%8B.png" <img src="/"></p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>Queue:  队列，是 RabbitMQ 的内部对象， 用 于存储消息。 RabbitMQ中，消息只能存储在队列中</p>
<p>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊 CRound-Robin ，即轮询)给多个消费者进行处理，而不是每个消费者都收到所有的消息井处理</p>
<h3 id="交换器，路由键，绑定"><a href="#交换器，路由键，绑定" class="headerlink" title="交换器，路由键，绑定"></a>交换器，路由键，绑定</h3><p>Exchange: 交换器 ，生产者将消息发送到 Exchange ，由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。 </p>
<p>RoutingKey: 路由键，生产者将消息发给交换器 的时候, 一般会指定一个RoutingKey ，用来指定这个消息的路由规则，而这个 RoutingKey 需要与交换器类型和绑定键 (BindingKey) 联合使用才能最终生效。 </p>
<p>Binding: 绑定 。 RabbitMQ 中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键 ( BindingKey ) ，这样 RabbitMQ 就知道如何正确地将消息路由 到 队列了 </p>
<h3 id="交换器类型"><a href="#交换器类型" class="headerlink" title="交换器类型"></a>交换器类型</h3><p>RabbitMQ 常用的交换器类型有 fanout 、 direct 、 topic 、 headers 这四种  </p>
<h4 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h4><p>它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。 </p>
<h4 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h4><p>direct 类型的交换器路由规则也很简单，它会把消息路由到那些 BindingKey 和 RoutingKey完全匹配的队列中。 </p>
<h4 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h4><p>topic 类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定: </p>
<p>​	1.RoutingKey 为一个点号”. “分隔的字符串(被点号” .”分隔开的每一段独立的字符<br>​	串称为一个单词 )，如 “com.rabbitmq.client”  </p>
<pre><code>  2.BindingKey 和 RoutingKey 一样也是点号&quot; .&quot;分隔的字符串;
</code></pre>
<p>​	3.BindingKey 中可以存在两种特殊字符串”*”和”#”，用于做模糊匹配其中”#”用&#96;于匹配一个单词，</p>
<p>​	吁”用于匹配多规格	单词(可以是零个)。 </p>
<h3 id="AMQP协议介绍"><a href="#AMQP协议介绍" class="headerlink" title="AMQP协议介绍"></a>AMQP协议介绍</h3><p>AMQP 协议本身包括三层：</p>
<p>~ Module Layer: 位于协议最高层，主要定义了一些供客户端调用的命令，客户端可以利<br>用这些命令实现自己的业务逻辑。例如，客户端可以使用 Queue . Declare 命令声明<br>一个队列或者使用 Basic.Consume 订阅消费一个队列中的消息。</p>
<p>~ Session Layer: 位于中间层，主要负责将客户端的命令发送给服务器，再将服务端的应<br>答返回给客户端，主要为客户端与服务器之间的通信提供可靠性同步机制和错误处理。</p>
<p>~ Transport Layer: 位于最底层，主要传输二进制数据流 ，提供帧的处理、信道复用、错<br>误检测和数据表示等。 </p>
<h2 id="客户端开发导向"><a href="#客户端开发导向" class="headerlink" title="客户端开发导向"></a>客户端开发导向</h2><h3 id="连接RabbitMQ"><a href="#连接RabbitMQ" class="headerlink" title="连接RabbitMQ"></a>连接RabbitMQ</h3><p>用来在给定的参数(lp 地址、端口号、用户名、密码等)下连接 RabbitMQ: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">factory.setUsername(USERNAME);</span><br><span class="line">factory.setPassword(PASSWORD);</span><br><span class="line">factory.setVirtualHost(virtualHost) ;</span><br><span class="line">factory.setHost(IP ADDRESS);</span><br><span class="line">factory.setPort(PORT) ;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> factory.newConnection(); </span><br></pre></td></tr></table></figure>

<p>可以选择使用 URI 的方式来实现 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span>口 ew <span class="title function_">ConnectionFactory</span><span class="params">()</span>;</span><br><span class="line">factory.setUri(<span class="string">&quot;amqp://userName:password@ipAddress:portNumber/virtualHost&quot;</span>);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"><span class="comment">//Connection 接口被用来创建一个 Channel:</span></span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> conn.createChannel();</span><br></pre></td></tr></table></figure>

<p>Connection 可以 用来创建多个 Channel 实例，但是 Channel 实例不能在线程问共享，<br>应用程序应该为每一个线程开辟一个 Channel 。 </p>
<h3 id="使用交换器和队列"><a href="#使用交换器和队列" class="headerlink" title="使用交换器和队列"></a>使用交换器和队列</h3><h4 id="exchangeDeclare-方法详解"><a href="#exchangeDeclare-方法详解" class="headerlink" title="exchangeDeclare 方法详解"></a>exchangeDeclare 方法详解</h4><p>exchangeDeclare 有多个重载方法，这些重载方法都是由下面这个方法中缺省的某些参数构成的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exchange.DeclareOk <span class="title function_">exchangeDeclare</span><span class="params">(String exchange ,String type,</span></span><br><span class="line"><span class="params">   <span class="type">boolean</span> durable,<span class="type">boolean</span> autoDelete , <span class="type">boolean</span> internal ,Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException ;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>1.exchange : 交换器的名称。<br>2.type : 交换器的类型，常见的如 fanout、 direct 、 topic ，<br>3.durable: 设置是否持久化 。 durable 设置为 true 表示持久化， 反之是非持久化 。<br>4.autoDelete : 设置是否自动删除。 autoDelete 设置为 true 则表示自动删除。自动删除是有一个队列或者交换器与这个交换器绑定 ， 之后所有与这个交换器绑定的队列或者交换器都与此解绑<br>5.internal : 设置是否是内置的。如果设置为 true ，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。<br>6.argument : 其他一些结构化参数，比如 a l ternate - exchange (有关 alternateexchange 的详情可以参考 4. 1.3 节)。 </p>
<h4 id="queueDeclare-方法详解"><a href="#queueDeclare-方法详解" class="headerlink" title="queueDeclare 方法详解"></a>queueDeclare 方法详解</h4><p>queueDeclare 相对于 exchangeDeclare 方法而言，重载方法的个数就少很多 ， 它只有两个重载方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 不带任何参数的 queueDeclare 方法默认创建一个由 RabbitMQ 命名的(类似这种</span></span><br><span class="line"><span class="comment">* amq.gen-LhQzlgv3GhDOv8PIDabOXA 名称，这种队列也称之为匿名队列〉、排他的、自动删除</span></span><br><span class="line"><span class="comment">* 的、非持久化的队列。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">Queue . DeclareOk <span class="title function_">queueDec1are</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">Queue. DeclareOk <span class="title function_">queueDeclare</span> <span class="params">(String queue , <span class="type">boolean</span> durable , <span class="type">boolean</span> exclusive,</span></span><br><span class="line"><span class="params"><span class="type">boolean</span> autoDelete, Map&lt;Str工 ng ， Object&gt; arguments)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>1.queue : 队列的名称。<br>2.durable: 设置是否持久化。为 true 则设置队列为持久化。<br>3.exclusive : 设置是否排他。为 true 则设置队列为排他的。如果一个队列被声明为排<br>他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。</p>
<p>​	注意：<br>​		排他队列是基于连接( Connection) 可见的，同一个连接的不同信道 (Channel)<br>​		是可以同时访问同一连接创建的排他队列; “首次”是指如果一个连接己经声明了 一个</p>
<p>​		排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同:即使该队<br>​		列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列<br>​		适用于一个客户端同时发送和读取消息的应用场景。</p>
<p>4.autoDelete: 设置是否自动删除。为 true 则设置队列为自动删除。自动删除的前提是:<br>至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会<br>自动删除。<br>5.argurnents: 设置队列的其他一些参数，如 x-rnessage-ttl 、 x-expires 、x -rnax-length 、 x-rnax-length-bytes 、 x-dead-letter-exchange 、 x-deadletter-routing-key, x-rnax-priority 等。 </p>
<h4 id="queueBind-方法详解"><a href="#queueBind-方法详解" class="headerlink" title="queueBind 方法详解"></a>queueBind 方法详解</h4><p>将队列和交换器绑定 的方法如下 ，可以与前两节中的方法定义进行类比 。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Queue.BindOk <span class="title function_">queueBind</span><span class="params">(String queue , String exchange , String routingKey)</span><span class="keyword">throws</span> IOException ;</span><br><span class="line"></span><br><span class="line">Queue.BindOk <span class="title function_">queueBind</span><span class="params">(String queue , String exchange , String routingKey,</span></span><br><span class="line"><span class="params">Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">queueBindNoWait</span><span class="params">(String queue , String exchange, String routingKey,</span></span><br><span class="line"><span class="params">Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOExce</span><br><span class="line">ption ;</span><br></pre></td></tr></table></figure>

<p>方法中涉及的参数详解。<br>1.queue: 队列名称:<br>2.exchange: 交换器的名称:<br>3.routingKey: 用来绑定队列和交换器的路由键;<br>4.argument: 定义绑定的一些参数。 </p>
<h4 id="exchangeBind-方法详解"><a href="#exchangeBind-方法详解" class="headerlink" title="exchangeBind 方法详解"></a>exchangeBind 方法详解</h4><p>不仅可以将交换器与队列绑定，也可以将交换器与交换器绑定， 相应的方法如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exchange.BindOk <span class="title function_">exchangeBind</span><span class="params">(String destination , String source , String routingKey)</span> </span><br><span class="line">  							<span class="keyword">throws</span> IOException;</span><br><span class="line">Exchange.BindOk <span class="title function_">exchangeBind</span><span class="params">(String destination , String source, String routingKey,</span></span><br><span class="line"><span class="params">                             Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException ;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">exchangeBindNoWait</span><span class="params">(String destination, String sour ce , String routingKey,</span></span><br><span class="line"><span class="params">							Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>RabbitMQ 的消费模式分两种 : 推 ( Push )模式和拉 ( Pull )模式 。 推模式采用 Basic . Consume进行消费，而拉模式则是调用 Basic . Get 进行消费。 </p>
<h4 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h4><p>在推模式中，可以通过持续订阅的方式来消费消息， 不同的订阅采用不同 的消费者标签 (consumerTag) 来区<br>分彼此，在同一个 Channe l 中的消费者也需要通过唯一的消费者标签 以作区分  </p>
<p>Channel 类中 basicConsume 方法有如下几种形式 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">basicConsume</span><span class="params">(String queue , Consumer callback)</span> <span class="keyword">throws</span> IOException ;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">basicConsume</span><span class="params">(String queue ， <span class="type">boolean</span> autoAck, Consumer callback)</span> <span class="keyword">throws</span> IOException ;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">basicConsume</span><span class="params">(String queue , <span class="type">boolean</span> autoAck, Map&lt;String, Object&gt; arguments </span></span><br><span class="line"><span class="params">	, Consumer callback)</span> <span class="keyword">throws</span> IOException ;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">basicConsume</span><span class="params">(String queue , boo l ean autoAck, String consumerTag</span></span><br><span class="line"><span class="params">	,Consumer callback)</span> <span class="keyword">throws</span> IOException ;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">basicConsume</span><span class="params">(String queue , <span class="type">boolean</span> autoAck, String consumerTag,<span class="type">boolean</span> noLocal </span></span><br><span class="line"><span class="params">	, <span class="type">boolean</span> exclusive, Map&lt;String，Object&gt; arguments ,Consumer callback)</span><span class="keyword">throws</span> IOException ; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其对应的参数说明如下所述。<br>1.queue : 队列的名称:<br>2.autoAck : 设置是否自动确认。建议设成 false ，即不自动确认:<br>3.consumerTag: 消费者标签，用来区分多个消费者:<br>4.noLocal : 设置为 true 则表示不能将同一个 Connection中生产者发送的消息传送给这个 Connection 中的消费者:<br>5.exclusive : 设置是否排他 :<br>6.arguments : 设置消费者的其他参数:<br>7.callback : 设置消费者的回调函数。用来处理 RabbitMQ 推送过来的消息，比如DefaultConsumer ,使用时需要客户端重写 (override) 其中的方法。 </p>
<h4 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h4><p>通过 channel . basicGet 方法可以单条地获取消息，其返回值是 GetResponeo  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetResponse <span class="title function_">basicGet</span><span class="params">(String queue , <span class="type">boolean</span> autoAck)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>



<p>Basic . Consume 将信道 (Channel) 直为接收模式，直到取消队列的订阅为止。在接收模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 Basic.Qos的限制.如果只想从队列获得单条消息而不是持续订阅，建议还是使用 Basic.Get 进行消费.但是不能将 Basic.Get 放在一个循环里来代替 Basic.Consume ，这样做会严重影响 RabbitMQ的性能.如果要实现高吞吐量，消费者理应使用 Basic.Consume 方法。 </p>
<h3 id="消费端确认与拒绝"><a href="#消费端确认与拒绝" class="headerlink" title="消费端确认与拒绝"></a>消费端确认与拒绝</h3><p>​	消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 等于 false时， RabbitMQ 会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记，之后再删除) 。当 autoAck 等于 true 时， RabbitMQ 会自动把发送出去的消息置为确认，然后从内存(或者磁盘)中删除，而不管消费者是否真正地消费到了这些消息 。 </p>
<p>​	当 autoAck 参数置为 false ，对于 RabbitMQ 服务端而言 ，队列中的消息分成了两个部分 :一部分是等待投递给消费者的消息:一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。 如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。 </p>
<p>​	<strong>RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开</strong> </p>
<p>消费者客户端可以调用channel.basicReject 方法来告诉 RabbitMQ 拒绝这个消息 ，定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicReject</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>deliveryTag 可以看作消息的编号 ，它是 一个 64 位的长整型值，最大值是9223372036854775807 。如果 requeue 参数设置为 true ，则 RabbitMQ 会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者;如果 requeue 参数设置为 false，则 RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。 </p>
<p>Basic.Reject 命令一次只能拒绝一条消息 ，如果想要批 量拒绝消息 ，则可以使用Basic.Nack 这个命令 。 消费者客户端可以调用 channel.basicNack 方法来实现 ,定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple, <span class="type">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>multiple 参数设置为 false 则表示拒绝编号为 deliveryTag的这 一条消息 ,multiple 参数设置为 true 则表示拒绝 deliveryTag 编号之前所有未被当前消费者确认的消息。 </p>
<p>AMQP 中还有一个命令 Basic.Recover 具备可重入队列的特性  ,定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Basic.RecoverOk <span class="title function_">basicRecover</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">Basic.RecoverOk <span class="title function_">basicRecover</span><span class="params">(<span class="type">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>channel.basicRecover 方法用来请求 RabbitMQ 重新发送还未被确认的消息 。 如果 requeue 参数设置为 true ，则未被确认的消息会被重新加入到队列中，这样对于同一条消息来说，可能会被分配给与之前不同的消费者。如果 requeue 参数设置为 false，那么同一条消息会被分配给与之前相同的消费者。默认情况下，如果不设置 requeue 这个参数，相当于<br>channel.basicRecover(true) ，即 requeue 默认为 true</p>
<h2 id="RabbtiMQ-进阶"><a href="#RabbtiMQ-进阶" class="headerlink" title="RabbtiMQ 进阶"></a>RabbtiMQ 进阶</h2><h3 id="mandatory-参数"><a href="#mandatory-参数" class="headerlink" title="mandatory 参数"></a>mandatory 参数</h3><p>mandatory 是 channel . basicPublish 方法中的参数 ，当 mandatory 参数设为 true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么 RabbitMQ 会调用 Basic.Return 命令将消息返回给生产者 。当 mandatory 参数设置为 false 时，出现上述情形，则消息直接被丢弃 。 </p>
<p>生产者 可以通过调用channel.addReturnListener 来添加 ReturnListener 监昕器获取RabbitMQ 调用Basic.Return 返回的消息。如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE NAME , <span class="string">&quot;&quot;</span>, <span class="literal">true</span>,MessageProperties.PERSISTENT TEXT PLAIN,</span><br><span class="line">                     <span class="string">&quot;mandatory test&quot;</span> . getBytes());</span><br><span class="line"><span class="comment">//添加监听</span></span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> <span class="title class_">ReturnListener</span>() (</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturn</span><span class="params">(<span class="type">int</span> replyCode,String replyText,String exchange,String routingKey,</span></span><br><span class="line"><span class="params">		AMQP.BasicProperties basicProperties,<span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println( <span class="string">&quot;Basic.Return 返回的结果是: &quot;</span>+message );</span><br><span class="line">		&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="备份交换器"><a href="#备份交换器" class="headerlink" title="备份交换器"></a>备份交换器</h3><p>可以通过在声明交换器(调用 channel.exchangeDeclare 方法)的时候添加alternate-exchange 参数来实现 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;a1ternate-exchange&quot;</span> , <span class="string">&quot;myAe&quot;</span>);</span><br><span class="line">channe1.exchangeDec1are( <span class="string">&quot;norma1Exchange&quot;</span> , <span class="string">&quot;direct&quot;</span> , <span class="literal">true</span> , fa1se , args);</span><br><span class="line">channe1.exchangeDec1are( <span class="string">&quot;myAe &quot;</span> , <span class="string">&quot;fanout&quot;</span> , <span class="literal">true</span>, fa1se , nu11) ;</span><br><span class="line">channe1.queueDec1are( <span class="string">&quot;norma1Queue &quot;</span> , <span class="literal">true</span> , fa1se , fa1se , nu11);</span><br><span class="line">channe1.queueBind( <span class="string">&quot; norma1Queue &quot;</span> ， <span class="string">&quot; norma1Exchange&quot;</span> , <span class="string">&quot; norma1Key&quot;</span>);</span><br><span class="line">channe1.queueDec1are( <span class="string">&quot;unroutedQueue &quot;</span> , <span class="literal">true</span> , fa1se , fa1se , nu11);</span><br><span class="line">channel.queueBind( <span class="string">&quot;unroutedQueue &quot;</span>, <span class="string">&quot;myAe &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>代码中声明了两个交换器 nonnallixchange 和 myAe，分别绑定了 nonnalQueue 和umoutedQueue 这两个队列，同时将 myAe 设置为 nonnallixchange 的备份交换器。注 意 myAe的交换器类型为 fanout。 </p>
<p>如果此时发送一条消息到 nonnalExchange 上，当路由键等于” nonnalKey” 的时候，消息能正确路由到 nonnalQueue 这个队列中。如果路由键设为其他值，比如 “errorKey飞即消息不能被正确地路由到与 nonnallixchange 绑定的任何队列上，此时就会发送给 myAe，进而发送到 unroutedQueue 这个队列 。 </p>
<p>对于备份交换器，总结了以下几种特殊情况:<br>1.如果设置的备份交换器不存在，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。<br>2.如果备份交换器没有绑定任何队列，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。<br>3.如果备份交换器没有任何匹配的队列，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。<br>4.如果备份交换器和 mandatory 参数一起使用，那么 mandatory 参数无效。 </p>
<h3 id="设置过期时间（TTL）"><a href="#设置过期时间（TTL）" class="headerlink" title="设置过期时间（TTL）"></a>设置过期时间（TTL）</h3><p>RabbitMQ 可以对消息和队列设置 TTL , 如果两种方法一起使用，则消息的 TTL 以两者之间较小的那个数值为准。消息在队列中的生存时间 一旦超过设置 的 TTL 值时，就会变成”死信” (Dead Message) ，消费者将无法再收到该消息 </p>
<h4 id="设置消息的TTL"><a href="#设置消息的TTL" class="headerlink" title="设置消息的TTL"></a>设置消息的TTL</h4><p><strong>1.通过队列属性设置消息 TTL</strong> </p>
<p>channel.queueDeclare 方法中加入x-message -ttl 参数实现的，这个参数的单位是毫秒。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; argss = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , Object&gt;();</span><br><span class="line">argss.put(<span class="string">&quot;x-message-ttl&quot;</span> , <span class="number">6000</span>);</span><br><span class="line">channel.queueDeclare(queueName,durable,exclusive,autoDelete,argss);</span><br></pre></td></tr></table></figure>

<p>如果将 TTL 设置为 0，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃 </p>
<p><strong>2.对每条消息设置 TTL</strong> </p>
<p>channel.basicPublish 方法中加入 expiration的属性参数，单位为毫秒。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder();</span><br><span class="line">builder.deliveryMode(<span class="number">2</span>); / / 持久化消息</span><br><span class="line">builder.expiration( <span class="string">&quot; 60000 &quot;</span> );/ / 设置 TTL=60000ms</span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> builder.build() ;</span><br><span class="line">channel.basicPublish(exchangeName, routingKey,mandatory,properties,<span class="string">&quot;ttlTestMessage&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p>对于第一种设置队列 TTL 属性的方法，一旦消息过期，就会从队列中抹去，而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。 </p>
<h4 id="设置队列的TTL"><a href="#设置队列的TTL" class="headerlink" title="设置队列的TTL"></a>设置队列的TTL</h4><p>通过 channel.queueDeclare 方法中的 x-expires 参数可以控制队列被自动删除前处于未使用状态的时间 ,未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段 内也未调用过 Basic.Get 命令(<strong>空闲时间</strong>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args =口 ew HashMap&lt;String, Object&gt;&#123;) ;</span><br><span class="line">args.put( <span class="string">&quot;x-expires&quot;</span> , <span class="number">1000</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue &quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,args) ;</span><br></pre></td></tr></table></figure>



<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>当消息在一个队列中变成死信 (dead message) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。 </p>
<p>消息变成死信一般是由于以下几种情况: </p>
<ul>
<li>1.消息被拒绝 (Basic.Reject&#x2F;Basic .Na ck) ，井且设置 requeue 参数为 false;</li>
<li>2.消息过期;</li>
<li>3.队列达到最大长度。</li>
</ul>
<p>当这个队列中存在死信时 ， RabbitMQ 就会自动地将这个消息重新发布到设置的 DLX 上去 ，进而被路由到另一个队列，即死信队列。 </p>
<p>通过在 channel.queueDeclare 方法中设置 x-dead-letter-exchange 参数来为这个队列添加 DLX </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;dlx_exchange &quot;</span> , <span class="string">&quot;direct &quot;</span>); <span class="comment">//创建 DLX: dlx_exchange</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span> , <span class="string">&quot;dlx exchange&quot;</span>);</span><br><span class="line"><span class="comment">//为队列 myqueue 添加 DLX</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,args);</span><br><span class="line"><span class="comment">//也可以为这个 DLX 指定路由键，如果没有特殊指定，则使用原队列的路由键:</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span> , <span class="string">&quot;dlx-routing-key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare( <span class="string">&quot;exchange.normal &quot;</span> , <span class="string">&quot;fanout&quot;</span> , <span class="literal">true</span>);</span><br><span class="line">Map&lt;String , Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;( );</span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span> , <span class="number">10000</span>);</span><br><span class="line">args.put( <span class="string">&quot;x-dead-letter-exchange&quot;</span> , <span class="string">&quot;exchange.dlx&quot;</span>);</span><br><span class="line">args.put( <span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;routingkey&quot;</span>);</span><br><span class="line">channe1.queueDec1are(<span class="string">&quot;.norma1 &quot;</span> , <span class="literal">true</span> , fa1se , fa1se , args);</span><br><span class="line">channe1.queueBind(<span class="string">&quot;queue.normal&quot;</span> , <span class="string">&quot;exchange.normal&quot;</span> , <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;exchange.dlx&quot;</span> , <span class="string">&quot;direct&quot;</span> , <span class="literal">true</span>);</span><br><span class="line">channe1.queueDec1are(<span class="string">&quot;queue.d1x&quot;</span> , <span class="literal">true</span> , <span class="literal">false</span> , <span class="literal">false</span> , <span class="literal">null</span>) ;</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue.dlx&quot;</span> , <span class="string">&quot;exchange.dlx&quot;</span> , <span class="string">&quot;routingkey&quot;</span>);</span><br><span class="line">channel.basicPublish(<span class="string">&quot;exchange.normal&quot;</span>,<span class="string">&quot;rk&quot;</span>,MessageProperties.PERSISTENT_TEXT_PLAIN,<span class="string">&quot;dlx&quot;</span>.getBytes()) ;</span><br></pre></td></tr></table></figure>

<p>生产者首先发送一条携带路由键为 “ rk “ 的消息，然后经过交换器exchange .normal 顺利地存储到队列 queue.normal 中 。由于队列 queue.normal 设置了过期时间为10s ， 在这 10s 内没有消费者消费这条消息，那么判定这条消息为过期。由于设置了 DLX ， 过期之时 ， 消息被丢给交换器 exchange.dlx 中，这时找到与exchange.dlx匹配的队列 queue .dlx ， 最后消息被存储在 queue.dlx 这个死信队列中。 </p>
<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>所谓”延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费 。 </p>
<p>常见使用场景：</p>
<ul>
<li>在订单系统中， 一个用户下单之后通常有 30 分钟的时间进行支付，如果 30 分钟之内没有支付成功，那么这个订单将进行异常处理，这时就可以使用延迟队列来处理这些订单了 。</li>
</ul>
<p>RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过前面所介绍的 DLX 和 TTL 模拟出延迟队列的功能。对于 queue.dlx 这个死信队列来说，同样可以看作延迟队列。假设一个应用中需要将每条消息都设置为 10 秒的延迟，生产者通过 exchange.normal 这个交换器将发送的消息存储在 queue.normal 这个队列中。消费者订阅的并非是 queue.normal 这个队列，而是 queue.dlx 这个队列 。当消息从 queue.normal 这个队列中过期之后被存入 queue.dlx 这个队列中，消费者就恰巧消费到了延迟 10 秒的这条消息 。  </p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级队列 ，指的是具有高优先级的队列具有高的优先权，优先级高的消息具备优先被消费的特权。 </p>
<p>可以通过设置队列的 <strong>x-max-priority</strong> 参数来实现 ，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;() ;</span><br><span class="line">args.put(<span class="string">&quot;x-rnax-priority&quot;</span>, <span class="number">10</span>) ;</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue.priority&quot;</span>, <span class="literal">true</span>, fa1se , <span class="literal">false</span> , args) ;</span><br></pre></td></tr></table></figure>

<p>设置消息的优先级，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.<span class="type">Bui1der</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder();</span><br><span class="line">builder.priority(<span class="number">5</span>);<span class="comment">//默认为0</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> builder.build () ;</span><br><span class="line">channel.basicPub1ish(<span class="string">&quot;exchange_priority&quot;</span>,<span class="string">&quot;rk_priority&quot;</span>,properties,(<span class="string">&quot;Messages&quot;</span> ).getBytes());</span><br></pre></td></tr></table></figure>

<h3 id="RPC实现"><a href="#RPC实现" class="headerlink" title="RPC实现"></a>RPC实现</h3><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>持久化可以提高 RabbitMQ 的可靠性， 以防在异常情况(重启、关闭、右机等)下的数据丢失 ，RabbitMQ的持久化分为三个部分:交换器的持久化、队列的持久化和消息的持久化 </p>
<h4 id="交换器持久化"><a href="#交换器持久化" class="headerlink" title="交换器持久化"></a>交换器持久化</h4><p>交换器的持久化是通过在声明交换器时将 durable 参数置为 true 实现的 ，如果交换器不设置持久化，那么在 RabbitMQ 服务重启之后，相关的交换器元数据会丢失，不过消息不会丢失，只是不能将消息发送到这个交换器中了。对一个长期使用的交换器来说，建议将其置为持久化的。 </p>
<h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><p>队列的持久化是通过在声明队列时将 durable 参数置为 true 实现的 ，如果队列不设置持久化，那么在 RabbitMQ 服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。 </p>
<h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>通过将消息的投递模式(BasicPropert i es 中的 deliveryMode 属性)设置为 2 即可实现消息的持久化 </p>
<p>将所有消息都设置为持久化，将严重影响RabbitMQ的性能，所以，可以将可靠性不是那么高的消息不设置成持久性的，需要在可靠性和持久性之间做一个权衡。</p>
<p><strong>问题： 将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗?</strong> </p>
<p>1.如果在订阅消费队列时将 autoAck 参数设置为 true，那么 当消费者接收到相关消息之后，还没来得及处理就看机了，这样也算数据丢失。 </p>
<p>解决办法：将autoAck 参数设置为 false ， 并进行手动确认。</p>
<p>2.在持久化的消息正确存入 RabbitMQ 之后，还需要有一段时间(虽然很短，但是不可忽视〉才能存入磁盘之中。RabbitMQ 并不会为每条消息都进行同步存盘(调用内核的 fsyncl方法)的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。 </p>
<p>解决办法：引入镜像队列机制，相当于把消息备份一遍，或者在发送端引入事务机制或者发送方确认机制来保证消息己经正确地发送并存储至RabbitMQ，前提还要保证在调用 channel.basicPublish 方法的时候交换器能够将消息正确路由到相应的队列之中，所以可以配合mandtroy参数使用</p>
<h3 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h3><p>RabbitMQ 针对这个问题，提供了两种解决方式:</p>
<ul>
<li>通过事务机制实现:</li>
<li>通过发送方确认 C publisher confirm ) 机制实现。</li>
</ul>
<h4 id="事物机制"><a href="#事物机制" class="headerlink" title="事物机制"></a>事物机制</h4><p>Rabb itMQ 客户端中与事务机制相关的方法有 三 个: </p>
<ul>
<li>channel . txSelect<ul>
<li>用于将当前的信道设置成事务模式.</li>
</ul>
</li>
<li>channel . txCommit <ul>
<li>用于提交事务</li>
</ul>
</li>
<li>channel . txRollbacko<ul>
<li>用于事务回滚</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">	channel.txSelect() ;</span><br><span class="line">	channel.basicPublish(exchange,routingKey,MessageProperties.PERSISTENT_TEXT_PLAIN, 				msg.getBytes());</span><br><span class="line">	<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span> ;</span><br><span class="line">	channel . txCommit() ;</span><br><span class="line">) <span class="keyword">catch</span> (Exception e) (</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事物模式：调用channel.txSelect 会不会阻塞其他命令执行? </p>
<p>是</p>
<h4 id="发送发确认机制"><a href="#发送发确认机制" class="headerlink" title="发送发确认机制"></a>发送发确认机制</h4><p><strong>生产者将信道设置成 confmn</strong> (确认)模式，一旦信道进入 confmn 模式，所有在<strong>该信道上面发布的消息都会被指派一个唯一的 IDC 从 l 开始)<strong>，一旦</strong>消息被投递到所有匹配的队列之后</strong>，<strong>RabbitMQ 就会发送一个确认 Basic.Ack) 给生产者(包含消息的唯一 ID)</strong> ，这就使得生产者知晓消息已经正确到达了目的地了。<strong>如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。 RabbitMQ 回传给生产者的确认消息中的 deliveryTag 包含了确认消息的序号，此外 RabbitMQ 也可以设置 channel . basicAck 方法中的 multiple 参数，表示到这个序号之前的所有消息都己经得到了处理.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  	<span class="comment">//将信道置为 publisher confirm 模式</span></span><br><span class="line">	channel.confirmSelect() ; </span><br><span class="line">	<span class="comment">//之后正常发送消息</span></span><br><span class="line">	channel .basicPublish(<span class="string">&quot;exchange&quot;</span>,<span class="string">&quot;routingKey&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;publisher confirm test &quot;</span>.getBytes());</span><br><span class="line">	<span class="keyword">if</span>(!channel.waitForConfirms()) &#123;</span><br><span class="line">      System.out .println( <span class="string">&quot;send message failed &quot;</span> ) ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// do something else..</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) (</span><br><span class="line">	e.printStackTrace() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果发送多条消息，只需要将 channel . basicPublish 和 channel.waitForConfirms 方法包裹在循环里面即可，可以参考事务机制，<strong>不过不需要把channel . confirmSelect 方法包裹在循环内部。</strong> </p>
<h5 id="批量-confirm-方法"><a href="#批量-confirm-方法" class="headerlink" title="批量 confirm 方法"></a>批量 confirm 方法</h5><p>每发送一批消息后，调用 channel.waitForConfirms方法，等待服务器的确认返回 。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	channel.confirmSelect();</span><br><span class="line">	<span class="type">int</span> <span class="variable">MsgCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		channel . basicPublish(<span class="string">&quot;exchange&quot;</span>,<span class="string">&quot;routingKey&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;batch confirm test &quot;</span>.getBytes());</span><br><span class="line">		<span class="comment">//将发送出去 的消息存入缓存中，缓存可以是</span></span><br><span class="line">		<span class="comment">//一个 ArrayList 或者 BlockingQueue 之类的</span></span><br><span class="line">		<span class="keyword">if</span> (++MsgCount &gt;= BATCHCOUNT) &#123;</span><br><span class="line">			MsgCount = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (channel.waitForConfirms()) &#123;</span><br><span class="line">					<span class="comment">//将缓存中的消息清空</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="comment">//将缓存中的消息重新发送</span></span><br><span class="line">                &#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				<span class="comment">//将缓存中 的消息重新发送</span></span><br><span class="line">            &#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace() ;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h5 id="异步-confirm-方法"><a href="#异步-confirm-方法" class="headerlink" title="异步 confirm 方法"></a>异步 confirm 方法</h5><p>提供一个回调方法，服务端确认了一条或者多条消息后客户端会因调这个方法进行处理。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">factory.setUsername(config.UserName);</span><br><span class="line">factory.setPassword(config.Password);</span><br><span class="line">factory.setVirtualHost(config.VHost);</span><br><span class="line">factory.setHost(config.Host);</span><br><span class="line">factory.setPort(config.Port);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"><span class="comment">// 创建信道</span></span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> conn.createChannel();</span><br><span class="line"><span class="comment">// 声明队列</span></span><br><span class="line">channel.queueDeclare(config.QueueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 开启发送方确认模式</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;时间 =&gt; %s&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().getTime());</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, config.QueueName, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步监听确认和未确认的消息</span></span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;未确认消息，标识：&quot;</span> + deliveryTag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;已确认消息，标识：%d，多个消息：%b&quot;</span>, deliveryTag, multiple));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="消费点要点介绍"><a href="#消费点要点介绍" class="headerlink" title="消费点要点介绍"></a>消费点要点介绍</h3><h4 id="消息分发"><a href="#消息分发" class="headerlink" title="消息分发"></a>消息分发</h4><p>当 RabbitMQ 队列拥有多个消费者时 ，队列收到的消息将以轮询 (round-robin )的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。 如果现在负载加重，那么只需要创建更多的消费者来消费处理消息即可。 </p>
<p><strong>问题：</strong>试想一下，如果某些消费者任务繁重，来不及消费那么多的消息，而某些其他消费者由于某些原因(比如业务逻辑简单、机器性能卓越等)很快地处理完了所分配到的消息，进而进程空闲，这样就会造成整体应用吞吐量的下降。 </p>
<p><strong>解决：</strong>channel.basicQos 方法允许限制信道上的消费者所能保持的最大未确认消息的数量。 </p>
<p>RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么 RabbitMQ 就不会向这个消费者再发送任何消息。直到消费者确认了某条消息之后 ， RabbitMQ 将相应的计数减1，之后消费者可以继续接收消息，直到再次到达计数上限。 </p>
<p><strong>注意要点：</strong></p>
<p>Basic.Qos 的使用对于拉模式的消费方式无效. </p>
<h4 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h4><h2 id="RabbitMQ-管理"><a href="#RabbitMQ-管理" class="headerlink" title="RabbitMQ 管理"></a>RabbitMQ 管理</h2><h3 id="多租户与权限"><a href="#多租户与权限" class="headerlink" title="多租户与权限"></a>多租户与权限</h3><p>每一个 RabbitMQ 服务器都能创建虚拟的消息服务器，我们称之为虚拟主机 (virtual host) ,简称为 vhost。每一个 vhost 本质上是一个独立的小型 RabbitMQ 服务器，拥有自己独立的队列、交换器及绑定关系等，井且它拥有自己独立的权限。 vhost 之间是绝对隔离的，无法将 vhostl 中的交换器与 vhost2 中的队列进行绑定 </p>
<p>客户端在连接的时候必须制定一个 vhost. RabbitMQ 默认创建的 vhost 为 “&#x2F;“ ， </p>
<p>创建一个新的 vhost :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nodel -]# rabbitmqctl add vhost vhostl</span><br><span class="line">Creating vhost &quot;vhostl&quot;</span><br></pre></td></tr></table></figure>

<p>删除vhost：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nodel -]# rabbitmqctl delete_vhost vhostl</span><br><span class="line">Deleting vhost &quot;vhostl&quot;</span><br></pre></td></tr></table></figure>

<p>AMQP 协议中并没有指定权限在 vhost 级别还是在服务器级别实现，由具体的应用自定义。<strong>在 RabbitMQ 中，权限控制则是以 vhost 为单位的 。当创建一个用户时，用户通常会被指派给至少一个 vhost，并且只能访问被指派的 vhost 内的队列、交换器和绑定关系等。</strong>因此， RabbitMQ中的授予权限是指在 vhost 级别对用户而言的权限授予 。 </p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>在 RabbitMQ 中，用 户是访 问 控制 ( Access Control)的基本单元，且单个用户可以跨越多个 vhost 进行授权。针对一至多个 vhost，用户可以被赋予不同级别的访问权限，并使用标准的用户名和密码来认证用户。 </p>
<p>添加用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nodel -] # rabbitmqctl add_user root root123</span><br><span class="line">Creating user &quot;root&quot;</span><br></pre></td></tr></table></figure>

<p>修改密码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nodel -] # rabbitmqctl change_password root root321</span><br><span class="line">Changing password for user &quot;root &quot;</span><br></pre></td></tr></table></figure>

<p>删除用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nodel - ]# rabbitmqctl delete user root</span><br><span class="line">Deleting user &quot;root&quot;</span><br></pre></td></tr></table></figure>

<p>查看所有用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@nodel - ]# rabbitmqctl list users</span><br><span class="line">Listing users</span><br><span class="line">guest [administrator]</span><br><span class="line">root []</span><br></pre></td></tr></table></figure>

<p>用户的角色分为 5 种类型:</p>
<ul>
<li>none: 无任何角色。新创建的用户的角色默认为 none 。</li>
<li>management : 可以访问 Web 管理页面。 Web 管理页面在 5.3 节中会有详细介绍 。</li>
<li>policymaker: 包含 management 的所有权限，并且可以 管理策略 ( Policy) 和参数( Parameter)。详细内容可参考 6.3 节。</li>
<li>monitoring: 包含 management 的所有权限，并且可以看到所有连接、信道及节点相关的信息。</li>
<li>administartor: 包含 monitoring 的所有权限，井且可以管理用户、 虚拟主机、权限、策略、参数等。 administator 代表了最高的权限 。</li>
</ul>
<h3 id="web端管理"><a href="#web端管理" class="headerlink" title="web端管理"></a>web端管理</h3><h3 id="应用与集群管理"><a href="#应用与集群管理" class="headerlink" title="应用与集群管理"></a>应用与集群管理</h3><h4 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h4><p>rabbitmqctl stop [pid_file] </p>
<p>用于停止运行 RabbitMQ 的 Erlang 虚拟机和 RabbitMQ 服务应用。如果指定了 pid_file ，还需要等待指定进程的结束。 </p>
<p>rabbitmqctl shutdown </p>
<p>用于停止运行 RabbitMQ 的 Erlang 虚拟机和 RabbitMQ 服务应用。执行这个命令会阻塞直到 Erlang 虚拟机进程退出。如果 RabbitMQ 没有成功关闭，则会返回一个非零值。 </p>
<p>rabbitmqctl stop_ app </p>
<p>停止 RabbitMQ 服务应用，但是 Erlang 虚拟机还是处于运行状态。此命令的执行优先于其他管理操作(这些管理操作需要先停止 RabbitMQ 应用)，比如 rabbitmqctl reset 。</p>
<p>rabbitmqctl start_ app </p>
<p>启动 RabbitMQ 应用。 此命令典型的用途是在执行了其他管理操作之后，重新启动之前停止的 RabbitMQ 应用，比如 rabbi tmqctl reset 。  </p>
<p>rabbitmqctl reset </p>
<p>将 RabbitMQ 节点重置还原到最初状态。包括从原来所在的集群中删除此节点，从管理数据库中删除所有的配置数据，如己配置的用户、 vhost 等，以及删除所有的持久化消息。执行rabbitmqctl reset 命令前必须停止RabbitMQ 应用(比如先执行 rabbitmqctlstop_app) 。 </p>
<p>rabbitmqctl force_reset </p>
<p>强制将 RabbitMQ 节点重置还原到最初状态。不同于 rabbitmqctl reset 命令，rabbitmqctl force reset 命令不论当前管理数据库的状态和集群配置是什么，都会无条件地重直节点。它只能在数据库或集群配置己损坏的情况下使用。与 rabbitmqctl reset命令一样，执行 rabbitmqctl force reset 命令前必须先停止 RabbitMQ 应用。 </p>
<h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h4><h2 id="RabbitMQ运维"><a href="#RabbitMQ运维" class="headerlink" title="RabbitMQ运维"></a>RabbitMQ运维</h2><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p>RabbitMQ 集群中 的所有节点都会备份所有的元数据信息，包括以下内容。 </p>
<ul>
<li>队列元数据 : 队列的名称及属性 ;</li>
<li>交换器:交换器的名称及属性 :</li>
<li>绑定关系元数据 : 交换器与队列或者交换器与交换器之间 的绑定关系 ;</li>
<li>vhost 元数据:为 vhost 内的队列、交换器和绑定提供命名空间及安全属性。</li>
</ul>
<p>但是不会备份消息，所以RabbitMQ 集群不能保证消息的万无一失 ， 即将消息 、 队列 、 交换器等都设置为可持<br>久化 ， 生产端和消费端都正确地使用了确认方式, 通过特殊的配置比如镜像队列可以解决这个问题 。</p>
<p>在 RabbitMQ 集群中创建队列，集群只会在单个节点而不是在所有节点上创建队列的进程井包含完整的队列信息(元数据 、状态、内容)。这样只有队列的宿主节点 ， 即所有者节点知道队列的所有信息 ， 所有其他非所有者节点只知道队列的元数据和指向该队列存在的那个节点的指针。因此当集群节点崩溃时，该节点的队列进程和关联的绑定都会消失。附加在那些队列上的消费者也会丢失其所订阅的信息 ， 井且任何匹配该队列绑定信息的新消息也都会消失。 </p>
<p>当创建一个新的交换器时， RabbitMQ 所要做的就是将绑定列表添加到集群中的所有节点上。这样，每个节点上的每条信道都可以访问到新的交换器了。 </p>
<h4 id="多机多节点配置"><a href="#多机多节点配置" class="headerlink" title="多机多节点配置"></a>多机多节点配置</h4><p>在每台机器中部署一个 RabbitMQ服务节点，进而由多台机器组成一个 RabbitMQ 集群。 </p>
<p>准备三台机器</p>
<ul>
<li>192.168.0.2 </li>
<li>192.168.0.3 </li>
<li>192.168.0.4</li>
</ul>
<p>修改hots文件，添加ip与节点映射信息</p>
<ul>
<li>192.168.0.2 node1</li>
<li>192.168.0.3 node2</li>
<li>192.168.0.4 .node3</li>
</ul>
<p>编辑 RabbitMQ 的 cookie 文件，以确保各个节点的 cookie 文件使用的是同一个值，可以读取 node1 节点的 cookie 值 ， 然后将其复制到 node2 和 node3 节点中 </p>
<ul>
<li>Linux 环境cookie 文件默认路径为 &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang . cookie 或者 $HOME&#x2F; . erlang.cookieo </li>
<li>windows 为C:\Users\Administrator\.erlang.cookie</li>
</ul>
<p>通过 rabbitmqctl 工具的方式配置集群  </p>
<ul>
<li>​	使用rabbitmq-server -detached 命令分别启动三个节点<ul>
<li>以 nodel 节点为基准，将 node2 和 node3 节点加入 nodel 节点的集群中,顺序可以调整</li>
<li>将node2 添加到node1集群中，需要如下步骤</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 -]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 -]# rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@node2</span><br><span class="line">[root@node2 -]# rabbitmqctl join_cluster rabbit@nodel</span><br><span class="line">Clustering node rabbit@node2 with rabbit@nodel</span><br><span class="line">[root@node2 -]# rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@node2</span><br></pre></td></tr></table></figure>

<p>使用命令rabbitmqctl cluster status  查看节点状态</p>
<p>说明：</p>
<ul>
<li>启动参数-detached<ul>
<li>让rabbitmq以后台守护线程启动，不受shell线程关闭影响</li>
</ul>
</li>
<li>节点关闭<ul>
<li>如果关闭了集群中的所有节点，则需要确保在启动的时候最后关闭的那个节点是第一个启<br>动的。如果第一个启动的不是最后关闭的节点，那么这个节点会等待最后关闭的节点启动。这<br>个等待时间是 30 秒，如果没有等到，那么这个先启动的节点也会失败。在最新的版本中会有重<br>试机制 ， 默认重试 10 次 30 秒以等待最后关闭的节点启动。</li>
</ul>
</li>
</ul>
<h4 id="集群节点类型"><a href="#集群节点类型" class="headerlink" title="集群节点类型"></a>集群节点类型</h4><p>RabbitMQ 中的每一个节点 ，不管是单一节点系统或者是集群中的一部分 ，要么是<strong>内存节点</strong>(ram)，要么是<strong>磁盘节点</strong>(disc)。 内存节点将所有的队列、 交换器、绑定关系、用户、权限和 vhost的元数据定义都存储在内存中，而磁盘节点则将这些信息存储到磁盘中。 </p>
<p><strong>指定内存节点命令:rabbitmqctl join_cluster rabbit@nodel –ram  通过–ram指定为内存节点,默认不加–ram为磁盘节点</strong></p>
<p><strong>切换节点类型命令:rabbitmqctl change cluster_node_type disc或ram</strong></p>
<p><strong>如何选择内存节点和磁盘节点：</strong></p>
<p><strong>磁盘节点</strong></p>
<p>RabbitMQ 只要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点。当节点加入或者离开集群时，它们必须将变更通知到至少一个磁盘节点。如果只有一个磁盘节点，而且如果该磁盘节点崩溃了，那么集群可以继续发送或者接收消息，但是不能执行创建队列、交换器、绑定关系、用户，以及更改权限、添加或删除集群节点的操作了。也就是说，如果集群中唯一的磁盘节点崩溃，集群仍然可以保持运行 ， 但是直到将该节点恢复到集群前，你无法更改任何东西。所以在建立集群的时候应该保证有两个或者多个磁盘节点的存在。 </p>
<p><strong>内存节点</strong></p>
<p>在内存节点重启后，它们会连接到预先配置的磁盘节点，下载当前集群元数据的副本。当在集群中添加内存节点时，确保告知其所有的磁盘节点(内存节点唯一存储到磁盘的元数据信息是集群中磁盘节点的地址)。只要内存节点可以找到至少一个磁盘节点，那么它就能在重启后重新加入集群中。 </p>
<h4 id="剔除单个节点"><a href="#剔除单个节点" class="headerlink" title="剔除单个节点"></a>剔除单个节点</h4><p>方式一</p>
<p>加入需要剔除节点node2 ,剔除步骤分以下情况</p>
<ul>
<li>node2 节点上执行 rabbitmqctl stop_app 或者 rabbitmqctl stop命令来关闭 RabbitMQ 服务 </li>
<li>再在 nodel 节点或者 node3 节点上执行 rabbitmqctlforget_cluster_node rabbit@node2 命令将 nodel 节点剔除出去</li>
</ul>
<p>方式二</p>
<p>在 node2 上执行 rabbitmqctl reset 命令</p>
<p>rabbi tmqctl reset 命令将清空节点的状态 ， 并将其恢复到空白状态。当重设的节点是集群中的一部分时 ， 该命令也会和集群中的磁盘节点进行通信 ， 告诉它们该节点正在离开集群。不然集群会认为该节点出了故障 ， 并期望其最终能够恢复过来。 </p>
<h4 id="集群节点升级"><a href="#集群节点升级" class="headerlink" title="集群节点升级"></a>集群节点升级</h4><h4 id="单机多节点"><a href="#单机多节点" class="headerlink" title="单机多节点"></a>单机多节点</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010887744/article/details/78377634">案例地址</a></p>
<p>###查看服务日志</p>
<h3 id="单节点故障恢复"><a href="#单节点故障恢复" class="headerlink" title="单节点故障恢复"></a>单节点故障恢复</h3><p>单节点故障包括:</p>
<ul>
<li>机器硬件故障</li>
<li>机器掉电</li>
<li>网络异常</li>
<li>服务进程异常</li>
</ul>
<h4 id="机器硬件故障"><a href="#机器硬件故障" class="headerlink" title="机器硬件故障"></a>机器硬件故障</h4><p>单节点机器硬件故障包括机器硬盘、内存、主板等故障造成的死机，无法从软件角度来恢复 </p>
<p>在集群中的其他节点中执行 rabbitmqctl forget cluster node{nodename} 命令来将故障节点剔除， 将故障节点的 IP地址从连接列表里删除，并让客户端重新与集群中的节点建立连接，以恢复整个应用  </p>
<h4 id="机器掉电"><a href="#机器掉电" class="headerlink" title="机器掉电"></a>机器掉电</h4><p>当遇到机器掉电故障，需要等待电源接通之后重启机器。此时这个机器节点上的 RabbitMQ处于 stop 状态，但是<strong>此时不要盲目重启服务，否则可能会引起网络分区</strong> </p>
<p>在其他节点上执行 rabbitmqctl forget_cluster_node{nodename} 命令将此节点从集群中剔除，然后删除当前故障机器的 RabbitMQ 中的 Mnesia数据(相当于重置)，然后再重启 RabbitMQ 服务，最后再将此节点作为一个新的节点加入到当前集群中 。 </p>
<h4 id="网络异常"><a href="#网络异常" class="headerlink" title="网络异常"></a>网络异常</h4><p>网线松动或者网卡损坏都会引起网络故障的发生。对于网线松动，无论是彻底断开，还是”藕断丝连”，只要它不降速， RabbitMQ 集群就没有任何影响 。 但是为了保险起见，建议先关闭故障机器的 RabbitMQ 进程，然后对网线进行更换或者修复操作，之后再考虑是否重新开启RabbitMQ 进程 。 而网卡故障极易引起网络分区的发生，如果监控到网卡故障而网络分区尚未发生时，理应第一时间关闭此机器节点上的 RabbitMQ 进程，在网卡修复之前不建议再次开启 。如果己经发生了网络分区 </p>
<h4 id="服务进程异常"><a href="#服务进程异常" class="headerlink" title="服务进程异常"></a>服务进程异常</h4><p>对于服务进程异常，如 RabbitMQ 进程非预期终止，需要预先思考相关风险是否在可控范围之内。如果风险不可控，可以选择抛弃这个节点。 一般情况下，重新启动 RabbitMQ 服务进程即可。 </p>
<h3 id="集群迁移"><a href="#集群迁移" class="headerlink" title="集群迁移"></a>集群迁移</h3><h2 id="RabbitMQ-高阶"><a href="#RabbitMQ-高阶" class="headerlink" title="RabbitMQ  高阶"></a>RabbitMQ  高阶</h2><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>RabbitMQ 的持久层 分为两部分</p>
<ul>
<li>队列索引（rabbit queue index ）<ul>
<li>负责维护队列中落盘消息的信息，包括消息的存储地点、是否己被交付给消费者、是否己被消费者 ack 等。</li>
<li>每个队列都有与之对应的一个 rabbit queue index</li>
</ul>
</li>
<li>消息存储（rabbit_msg_store）<ul>
<li>以键值对的形式存储消息，负责非持久化消息的持久化，重启后消息会丢失 </li>
<li>在每个节点中有且只有一个</li>
</ul>
</li>
</ul>
<p>消息(包括消息体、属性和 headers) 可以直接存储在 rabbit queue index 中，也可以被保存在 rabbit_msg_store 中，最佳的配置是，较小的消息存储在rabbit_queue_index中，较大的存储在rabbit_msg_store中，这个计量大小的阈值设置，默认为4069B</p>
<p>rabbit queue index 中以顺序(文件名从 0 开始累加〉的段文件来进行存储，后缀为” . idx “ ，每个段文件中包含固定的 SEGMENT ENTRY COUNT 条记录，默认值为 16384 。<strong>每个 rabbit_queue_index 从磁盘中读取消息的时候至少要在内存中维护一个段文件</strong>，所以设置 queue index embed msgs below 值的时候要格外谨慎 ， 一点点增大也可能会引起内存爆炸式的增长。 </p>
<p>经过 rabbit msg store处理的所有消息都会以追加的方式写入到文件中,当一个文件的大小超过指定的限制(file_sizelimit) 后 ，关闭这个文件再创建一个新的文件以供新的消息写入。文件名(文件后缀是”. rdq”) 从 0 开始进行累加 ， 因此文件名最小的文件也是最老的文件。在进行消息的存储时， RabbitMQ 会在 ETS (Erlang Term Storage) 表中记录消息在文件中的位置映射 (Index) 和文件的相关信息(FileSummary )。 </p>
<p><strong>读取消息</strong>的时候，先根据消息的 ID (msg id) 找到对应存储的文件，如果文件存在并且未被锁住，则直接打开文件，从指定位置读取消息的内容。如果文件不存在或者被锁住了，则发送请求由 rabbit_msg_store 进行处理。 </p>
<p><strong>消息的删除</strong>只是从 ETS 表删除指定消息的相关信息 ， 同时更新消息对应的存储文件的相关信息。执行消息删除操作时，井不立即对在文件中的消息进行删除，也就是说消息依然在文件中，仅仅是标记为垃圾数据而己 </p>
<p>当一个文件中都是垃圾数据时可以将这个文件删除 。当检测到前后两个文件中的有效数据可以合并在一个文件中，井且所有的垃圾数据的大小和所有文件(至少有 3 个文件存在的情况下〉的数据大小的比值超过设置的阑值 GARBAGE FRACTION (默认值为 0.5) 时才会触发垃圾回收将两个文件合井 。 </p>
<p>执行合井的两个文件一定是逻辑上相邻的两个文件 。 执行合并时首先锁定这两个文件，井先对前面文件中的有效数据进行整理，再将后面文件的有效数据写入到前面的文件，同时更新消息在 ETS 表中的记录，最后删除后面的文件。 </p>
<h4 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h4><p>通常队列由 rabbit_amqqueue_process 和 backing_queue 这两部分组成</p>
<ul>
<li>rabbit_amqqueue_process<ul>
<li>负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认(包括生产端的 confirm 和消费端的 ack) 等</li>
</ul>
</li>
<li>backing_queue<ul>
<li>消息存储的具体形式和引擎，并向 rabbit_amqqueue_process 提供相关的接口以供调用 。如果消息投递的目的队列是空的，并且有消费者订阅了这个队列，那么该消息会直接发送给消费者，不会经过队列这一步。而当消息无法直接投递给消费者时，需要暂时将消息存入队列，以便重新投递。</li>
</ul>
</li>
</ul>
<p>消息的状态会不断发生变化。 RabbitMQ 中的队列消息可能会处于以下 4 种状态。 </p>
<ul>
<li>alpha: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中 。</li>
<li>beta: 消息内容保存在磁盘中，消息索引保存在内存中。</li>
<li>gamma: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。</li>
<li>delta: 消息内容和索引都在磁盘中 。</li>
</ul>
<p>对于持久化的消息，消息内容和消息索引都必须先保存在磁盘上，才会处于上述状态中的一种 。 <strong>而 gamma 状态的消息是只有持久化的消息才会有的状态。</strong> </p>
<p>RabbitMQ 在运行时会根据统计的消息传送速度定期计算一个当前内存中能够保存的最大消息数量 (target_ram_count) ，如果 alpha 状态的消息数量大于此值时，就会引起消息的状态转换，多余的消息可能会转换到 beta 状态、 gamma 状态或者 delta 状态。 </p>
<p>区分这 4 种状态的主要作用是满足不同的内存和 CPU 需求</p>
<ul>
<li>alpha 状态最耗内存，但很少消耗 CPU</li>
<li>delta状态基本不消耗内存，但是需要消耗更多的 CPU 和磁盘I0 操作,需要执行两次Io 操作才能读取到消息， 一次是读消息索引(从 rabbit queue index 中)， 一次是读消息内容(从 rabbit_msg_store 中); </li>
<li>beta 和 gamma 状态都只需要一次I0 操作就可以读取到消息(从 rabbit msg store 中)。</li>
</ul>
<h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3><p>惰性队列会尽可能地将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中， 设计目标是为了延长队列，使队列能够存储更多的消息当消费者由于各种各样的原因(比如消费者下线、岩机 ， 或者由于维护而关闭等〉致使长时间 内不能消费消息而造成堆积时 ， 惰性队列就很有必要了。</p>
<p>默认情况下，RabbitMQ 接收的时候 ， 队列中的消息会尽可能地存储在内存之中，这样可以更加快速地将消息发送给消费者。 即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。</p>
<p>惰性队列会将接收到的消息直接存入文件系统中，而不管是持久化的或者是非持久化的，这样可以减少了内存的消耗，但是会增加IO 的使用，注意如果惰性队列中存储的是非持久化的消息，内存的使用率会一直很稳定，但是重启之后消息一样会丢失。 </p>
<p>队列具备两种模式: default 和 lazy。默认的为 default 模式 ,通过调用 channel .queueDeclare 方法的时候在参数中设置队列模式，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , Object&gt;();</span><br><span class="line">args.put( <span class="string">&quot;x-queue-mode &quot;</span> , <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span> , <span class="literal">false</span> , <span class="literal">false</span> , args);</span><br></pre></td></tr></table></figure>

<p> Policy 设置方式为: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^myqueue$&quot; &#x27;&#123;&quot;queue-mode &quot;:&quot; lazy&quot;&#125;&#x27; --apply-to-queues</span><br></pre></td></tr></table></figure>

<p>如果要将普通队列转变为惰性队列，那么我们需要忍受同样的性能损耗 ， 首先需要将缓存中的消息换页至磁盘中，然后才能接收新的消息。反之，当将一个惰性队列转变为普通队列的时候，和恢复一个队列执行同样的操作，会将磁盘中的消息批量地导入到内存中。 </p>
<h3 id="内存及磁盘警告"><a href="#内存及磁盘警告" class="headerlink" title="内存及磁盘警告"></a>内存及磁盘警告</h3><p>当内存使用超过配置的阑值或者磁盘剩余空间低于配置的阑值时， RabbitMQ 都会暂时阻塞( block) 客户端的连接( Connection) 井停止接收从客户端发来的消息，以此避免服务崩溃。与此同时，客户端与服务端的心跳检测也会失效。 </p>
<h4 id="内存警告"><a href="#内存警告" class="headerlink" title="内存警告"></a>内存警告</h4><p>RabbitMQ 服务器会在启动或者执行 rabbitmqctl set_Vffi_memory_high_watermarkfractio口命令时计算系统内存的大小。默认情况下 vffi memory high watermark 的值为 0 .4，<br>即内存阑值为 0.4， 表示当 RabbitMQ 使用的内存超过 40%时，就会产生内存告警井阻塞所有生产<br>者的连接。一旦告警被解除(有消息被消费或者从内存转储到磁盘等情况的发生)， 一切都会恢复<br>正常。 </p>
<p>内存阔值可以通过 rabbitmq.config 配置文件来配置，下面示例中设置了默认的 内存闽值为 0.4: </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    rabbit<span class="punctuation">,</span><span class="punctuation">[</span></span><br><span class="line">    	<span class="punctuation">&#123;</span>vm_memory_high_watermark<span class="punctuation">,</span><span class="number">0.4</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>rabbitmqctl 系列的命令为 : </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set vm memory high watermark &#123;0.4&#125;</span><br></pre></td></tr></table></figure>





<h4 id="磁盘警告"><a href="#磁盘警告" class="headerlink" title="磁盘警告"></a>磁盘警告</h4><p>当剩余磁盘空间低于确定的闽值时， RabbitMQ 同样会阻塞生产者，这样可以避免因非持久化的消息持续换页而耗尽磁盘空间导致服务崩溃。默认情况下，磁盘阑值为 50MB</p>
<p>RabbitMQ 会定期检测磁盘剩余空 间，检测的频率与上一次执行检测到的磁盘剩余空间大小有关。正常情况下，每 10 秒执行一次检测，随着磁盘剩余空间与磁盘阑值的接近，检测频率会有所增加。当要到达磁盘阑值时，检测频率为每秒 10 次，这样有可能会增加系统的负载 。 </p>
<h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>RabbitMQ 还引入了流控 C Flow Control)机制来确保稳定性。流控机制是用来避免消息的发送速率过快而导致服务器难以支撑的情形 。内存和磁盘告警相当于全局的流控 C Global Flow Control) ， 一旦触发会阻塞集群中所有的Connection ，而本节的流控是针对单个 Connection 的，可以称之为 Per-Connection Flow Control或者 Intemal Flow Control</p>
<h4 id="流控制原理"><a href="#流控制原理" class="headerlink" title="流控制原理"></a>流控制原理</h4><p>Erlang 进程之间并不共享内存(binay类型的除外)，而是通过消息传递来通信，每个进程都有自己的进程邮箱(mailbox) 。默认情况下 ， Erlang 并没有对进程邮箱的大小进行限制，所以当有大量消息持续发往某个进程时，会导致该进程邮箱过大，最终内存溢出并崩溃 。 在RabbitMQ 中，如果生产者持续高速发送，而消费者消费速度较低时 ，如果没有流控，很快就会使内部进程邮箱的大小达到内存阀值 。 </p>
<p><strong>信用证算法</strong> :</p>
<p>​	通过监控各个进程的进程邮箱，当某个进程负载过高而来不及处理消息时，这个进程的进程邮箱就会开始堆积消息 当堆积到一定量时，就会阻塞而不接收上游的新消息。从而慢慢地，上游进程的进程邮箱也会开始堆积消息 。当堆积到一定量时也会阻塞而停止接收上游的消息，最后就会使负责网络数据包接收的进程阻塞而暂停接收新的数据 。 </p>
<p>流控机制不只是作用于 Connection ，同样作用于信道 (Channel)和队列 。 从 Connection 到Channel ，再到队列，最后是消息持久化存储形成一个完整的流控链，对于处于整个流控链中的任意进程，只要该进程阻塞，上游的进程必定全部被阻塞 。 </p>
<p> class="lazyload" data-src="https://raw.githubusercontent.com/ExplorerMan9527/image/master/RabbitMQ-%E6%B5%81%E6%8E%A7%E9%93%BE.png" <img src="/"></p>
<p>其中的各个进程如下所述。</p>
<ul>
<li>rabbit_reader: Connection 的处理进程，负 责接收、解析 AMQP 协议数据包等。</li>
<li>rabbit_channel: Channel 的处理进程， 负责处理 AMQP 协议的各种方法、进行路由解析等 。</li>
<li>rabbit_amqqueue_process: 队列的处理进程，负责实现队列的所有逻辑 。</li>
<li>rabbit_msg_store: 负责实现消息的持久化 。</li>
</ul>
<h4 id="打破队列的瓶颈"><a href="#打破队列的瓶颈" class="headerlink" title="打破队列的瓶颈"></a>打破队列的瓶颈</h4><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>引入镜像队列 (Mirror Queue) 的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。 </p>
<p>在通常的用法中，针对每一个配置镜像的队列(以下简称镜像队列〉都包含一个主节点(master) 和若干个从节点 (slave)  </p>
<p> class="lazyload" data-src="https://raw.githubusercontent.com/ExplorerMan9527/image/master/RabbitMQ-master-slave.png" <img src="/"></p>
<p>如果 master 由于某种原因失效，根据 slave 加入的时间排序，时间最长的 slave 即称为新的master。发送到镜像队列的所有消息会被同时发往 master 和所有的 slave 上，如果此时 master 挂掉了，消息还会在 slave 上，这样 slave提升为 master 的时候消息也不会丢失。除发送消息 (Basic.Publish) 外的所有动作都只会向 master 发送，然后再由 master 将命令执行的结果广播给各个 slave 。 </p>
<p>镜像队列的配置主要是通过添加相应的 Policy 来完成的 ,举个例子，对队列名称以 “ queue_” 开头的所有队列进行镜像，并在集群的两个节点上完成镜像， Policy 的设置命令为 : </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy --priority 0 --apply-to queues mirror_queue &quot;^queue_&quot;</span><br><span class="line">&#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot; , &quot;ha-params &quot;: 2, &quot;ha-sync-mode &quot;: &quot;automatic&quot; &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ha-mode : 指明镜像队列的模式，有效值为 all 、 exactly 、 nodes ，默认为 all</p>
<ul>
<li><p>all 表示在集群中所有的节点上进行镜像 ; </p>
<p>exactly 表示在指定个数的节点上进行镜像，节点个数由 ha -params 指定; </p>
<p>nodes 表示在指定节点上进行镜像，节点名称通过 ha-params 指定，</p>
</li>
</ul>
</li>
<li><p>ha-params : 不同的 ha -mode 配置中需要用到的参数。</p>
</li>
<li><p>ha-syncmode : 队列中消息的同步方式，有效值为 automatic 和 manual 。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/723874b0d4fb">例子</a></p>
<h2 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h2><h3 id="网络分区的意义"><a href="#网络分区的意义" class="headerlink" title="网络分区的意义"></a>网络分区的意义</h3><p>当 一个集群发生网络分区时，这个集群会分成两个部分或者更多，它们各自为政，互相都认为对方分区内的节点                                                                                                                                                                                                                                        已经挂了，包括队列、交换器及绑定等元数据的创建和销毁都处于自身分区内，与其他分区无关 </p>
<p>如果原集群中配置了镜像队列，而这个镜像队列又牵涉两个或者更多个网络分区中的节点时 ，每一个网络分区中都会出现一个 master 节点，对于各个网络分区，此队列都是相互独立的。 </p>
<h3 id="网络分区的判定"><a href="#网络分区的判定" class="headerlink" title="网络分区的判定"></a>网络分区的判定</h3><p>超时判定机制  ：</p>
<p>网络分区的判定是与 net ticktirne 这个参数，默认值为 60 秒，heartbeat tirne 是指客户端与 RabbitMQ 服务之间通信<br>的心跳时间，针对 5672 端口而言</p>
<p>在RabbitMQ 集群内部的每个节点之间会每隔四分之一的net_ticktirne计一次应答( tick ) 如果有任何数据被写入节点中，则此节点被认为已经被应答( ticked ) 了。如果连续 4 次 ， 某节点都没有被 ticked ， 则可以判定此节点己处于 “ down” 状态 ， 其余节点可 以将此节点剥离出当前分区 。 </p>
<p><strong>查看网络分区：</strong></p>
<p>命令查看：采用 rabbitmqctl cluster status 命令 </p>
<p>未发生网络分区显示结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#123;nodes , [&#123;disc , [rabbit@nodel , rabbit@node2 , rabbit@node3]&#125;]&#125; ,</span><br><span class="line">&#123;running nodes , [rabbit@node2 , rabbit@node3 , rabbit@nodel]&#125; ,</span><br><span class="line">&#123;cluster name, &lt;&lt; &quot;rabbit@nodel &quot; &gt;&gt;&#125; ,</span><br><span class="line">&#123;partitio口 s ， [] &#125; ]</span><br></pre></td></tr></table></figure>

<p>发生网络分区显示结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#123;nodes , [&#123;disc , [rabbit@nodel , rabbit@node2 , rabbit@node3]&#125;] &#125;,</span><br><span class="line">&#123;running nodes , [rabbit@node3 , rabbit @nodel]&#125; ,</span><br><span class="line">&#123;cluster name , &lt;&lt; &quot;rabbit@nodel &quot; &gt;&gt;&#125; ,</span><br><span class="line">&#123;part 工 tions ， [&#123;rabbit@node3 , [rabbit@node2]&#125; , &#123;rabbit@nodel , [rabbit@node2]&#125;]&#125;]</span><br></pre></td></tr></table></figure>

<p>上面 partitions 项中的内容表示 :<br>( 1 ) rabbit@node3 与 rabbit@node2 发生了分区，即 {rabbit@node3 ， [rabbit@node2]} 。<br>( 2 ) rabbit@nodel 与 rabbit@node2 发生了分区 ，即 { rabbit@node3 ， [rabbit@node2 ]} 。 </p>
<p>Web管理界面查看：</p>
<p> class="lazyload" data-src="https://raw.githubusercontent.com/ExplorerMan9527/image/master/RabbitMQ%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA.png" <img src="/"></p>
<p>通过 Web 管理界面的方式查看。如果出现了图这种告警 ， 即发生了网络分区 </p>
<h3 id="网络分区模拟"><a href="#网络分区模拟" class="headerlink" title="网络分区模拟"></a>网络分区模拟</h3><h3 id="网络分区影响"><a href="#网络分区影响" class="headerlink" title="网络分区影响"></a>网络分区影响</h3><h3 id="手动处理网络分区"><a href="#手动处理网络分区" class="headerlink" title="手动处理网络分区"></a>手动处理网络分区</h3><h3 id="自动处理网络分区"><a href="#自动处理网络分区" class="headerlink" title="自动处理网络分区"></a>自动处理网络分区</h3><h2 id="RabbitMQ扩展"><a href="#RabbitMQ扩展" class="headerlink" title="RabbitMQ扩展"></a>RabbitMQ扩展</h2></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">WHXY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/17/rabbitmq/">http://example.com/2022/11/17/rabbitmq/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">WUHENG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2022/11/16/test2/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By WHXY</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>